class Solution {
    public int solution(int[][] routes) {
        int answer = 0;
        int min = -30000;
        int max = 30000;
        // 검사용 int 배열 만든다고 치고
        // 가는 범위에 모두 +1 박고.
        // 그럼 겹치는 정도가 나오는데.
        // 많이 겹치는 곳부터 CCTV를 다는 거.
        // 그럼 이때, 그 각 범위에 다시 -1을 박음.
        // 그러고 모든 곳이 1 이하라면, 남은 차량 대수만큼 CCTV를 더해주면 되긴 하는데.
        // 1. 이게 시간 효율이 좋을지를 모르겠으며
        // 2. 많이 겹치는 곳 순서로 하는 게 예외없이 무조건 최소 개수일지도 아직 모르겠음.
        // 근데 말이야. 범위가 6만이잖아. 차는 1만대고.
        // 이게이게.. 음..... 그리고 검사 배열도 그럼 길이가 6만1이 될 건데.. 괜찮나
        // 검사배열은 일단 매번 6만짜리를 할 필요는 없음. 근데 암튼 최대는 6만짜리라는 거.
        // 출발지 중에 최솟값, 도착지 중에 최댓값을 뽑아내면 되긴 하는데.
        // 근데 그 겹치는 정도는 표현이 되는데, 거기 있는 차가 뭔지는 어케 아냐. -> 차를 알아야 그 범위를 다 지움.
        for (int i = 0; i < routes.length; i++) { // 검사 범위 정하기 위한 최소, 최대값 검사
            int[] car = new int[2];
            car = routes[i];
            if (car[0] < min) {
                min = car[0];
            }
            if (car[1] > max) {
                max = car[1];
            }
        }
        return answer;
        // 겹치는 경우에는 몇 가지 있는데
        // 1. 완전히 안에 들어간 경우 => 안에 들어간 녀석의 범위에서 선택하면 됨.
        // 2. 애매하게 겹치는 경우 => 교집합의 범위에서 선택하면 됨. 사실 1번과 2번 둘 다 교집합에서 선택하는 거임.
        // 3. 출발or도착지점에 겹치는 경우 => 무조건 거기다 카메라 달아야 함. -> **최우선 순위** -> 양쪽 경계가 다 겹치면?
        // 양쪽 경계 다 겹치면 더 많이 겹치는 곳을 일단 해야....겠지?

        // 그럼 출발지점과 도착지점이 겹치는 경우를 먼저 탐색. 거기 카메라 달아버림. 그 범위를 포함하는 것도 검사.
        // 걔네는 다 빼고 계산할 거임 그럼.
        // 그 다음 교집합 있는지 검사인데, 이게 사실 어려운 거거든.
        // 예를 들어서
        // -----A-    -B------------C---
        //    -----------           ----------
        // 대충 이런 식이라고 쳐보자. 그럼 겹치는 곳이 지금 세 군데임.
        // 근데 이제 만약 여기서 B구간이 먼저 결정돼서 저기 CCTV를 두면
        // 총 3개의 CCTV를 필요로 함.
        // 당연히 A 구간과 C 구간에 둬서 2개를 하는 것이 최소임.
        // 이걸 코드로 어떻게 구분해낼 것인가.
        // 근데 일단 생각해보기에 한쪽 끝에서부터 가면 괜찮지 않을까 싶긴 하거든.
        // 물론 더 많이 겹치는 곳 위주로 하는 게 더 우선이고.
    }
}
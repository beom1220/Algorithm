# 구명보트

---

## 📌 **Algorithm**

---

- 그리디

## 📍 **Logic**

---

```java
import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        int boat = 0;
        // 구명보트 최대 2명에 무게제한도
        // 구명보트 사용횟수 최소로
        // 순서는 상관없는 듯.
        // 그럼 일단, limit에서 people[n]을 뺀 값이랑 작은 거를 비교해서 가능하면 같이 빼낸다는 느낌. 오케이?
        List<Integer> p = new ArrayList<>();
        for (int i = 0; i < people.length; i++) {
            p.add(people[i]);
        } // 최대 5만번이니까 문제 없을 듯.
        
        Collections.sort(p); // 작은 거부터 앞으로 오게끔.
        Collections.reverse(p); // 큰 거부터 앞으로.
        int i = p.size() - 1;
        for (int j = 0; j < p.size(); j++) {
            // 지우는 건 remove 말고 0 저장하자. 사람 무게 40키로 이상이라고 했음.
            if (p.get(j) == 0) {
                continue;
            }
            int remain = limit - p.get(j);
            p.set(j, 0);
            if (p.get(i) <= remain) { // 맨 앞이 젤 큰 거. 맨 뒤가 젤 작은 거니까 이렇게만 검사하면 됨.
                p.set(i, 0);
                i--;
            }
            boat++;
        }
        
        return boat;
    }
}
```

- 큰 순으로 정렬한 다음, 앞에서부터 빼낸다.
- 이때, 맨 뒤에 있는 사람이 가장 가벼운 사람이기 때문에, 현재 사람과 짝을 지어 내보낼 수 있는지 검사한다. 가능하면 같이 내보내고, 아니면 혼자 내보낸다.
- remove로 지우지 않고 set으로 0을 만든 이유는 우선, 사람 무게가 40키로 이상이기 때문에 0이 존재할 수 없으며, size를 이용하는 계산이 꼬일 수 있기 때문이었다.

## ✒️ **Review**

---

- 생각한 그대로 풀어졌다.
- 하지만, 또 약간의 뻘짓을 곁들였다. 그나마 이번엔 10분 내로 발견해내서 다행이었다.
- 가장 작은 값이랑 가장 큰 값을 짝지으려고 실컷 정렬을 해놓고서는, 뒤에 가서는 remain과 가장 근접한 몸무게를 찾는 이상한 코드를 짜고 앉아있었다.
- 그러니 정답은 나오지만, 이중 for문이라 효율성 테스트에서 문제가 생겼다.
- 왜 그러나 하면서 코드를 보다가, 그제서야 발견해내고 원래 의도대로 고쳐서 금방 다시 풀었다.
- 주석으로 생각했던 풀이 방법을 적으면서 풀려고 매번 하는데도 뭔가 덜 적거나 애매하게 적어서 코드 치다가 이상한 길로 종종 빠지는 것 같다. 처음 풀이를 생각할 때 좀 더 확실하게 적어두는 것도 역시 연습이 필요한 것 같다. 결론은 또 많이 풀어야 는다는 거.